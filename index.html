<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wee Chat</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="relative w-full h-screen overflow-hidden bg-black">
      <div class="relative w-full h-full">
        <div class="absolute inset-0 w-full h-full">
          <video
            id="remoteVideo"
            autoplay
            playsinline
            class="w-full h-full object-contain bg-black mirror"
          ></video>
        </div>

        <div
          id="placeholder"
          class="absolute inset-0 w-full h-full flex flex-col items-center justify-center bg-black z-2"
        >
          <div
            class="w-28 h-28 rounded-full border-2 border-neutral-600 flex items-center justify-center mb-5"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              class="w-14 h-14 fill-neutral-600"
            >
              <path
                d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
              />
            </svg>
          </div>
          <div class="text-lg text-neutral-400">
            Waiting for remote user to join...
          </div>
        </div>

        <div
          class="absolute bottom-5 right-5 w-32 h-44 rounded-lg overflow-hidden z-5"
        >
          <video
            id="localVideo"
            autoplay
            muted
            playsinline
            class="w-full h-full object-cover mirror"
          ></video>
        </div>
      </div>
      <div
        id="status"
        class="absolute top-5 right-5 text-sm border border-neutral-800 text-neutral-400 px-4 py-2 rounded-lg z-5 max-w-64 truncate"
      >
        Connecting...
      </div>
    </div>

    <script>
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const statusElement = document.getElementById("status");
      const placeholder = document.getElementById("placeholder");

      let socket = null;
      let localStream = null;
      let peerConnection = null;
      let clientId = null;

      init();

      async function init() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { min: 640, ideal: 1920, max: 1920 },
              height: { min: 480, ideal: 1080, max: 1080 },
              frameRate: { min: 24, ideal: 30, max: 30 },
              aspectRatio: 16 / 9,
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          localStream = stream;
          localVideo.srcObject = stream;

          connectToServer();
        } catch (error) {
          if (error instanceof Error) {
            setStatus(`Camera/mic error: ${error.message}`);
          } else {
            setStatus("Camera/mic error: Unknown error");
          }
        }
      }

      function connectToServer() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}`;
        socket = new WebSocket(wsUrl);

        socket.onopen = () => {
          setStatus("Waiting for another person...");
        };

        socket.onmessage = handleMessage;

        socket.onclose = () => {
          setStatus("Disconnected. Refresh to reconnect.");
          cleanup();
        };
      }

      function handleMessage(event) {
        const data = JSON.parse(event.data);
        console.log("Received message:", data);

        switch (data.type) {
          case "connection":
            clientId = data.id;
            setStatus(data.message || "Waiting for a partner...");
            break;

          case "paired":
            setStatus("Connected with a partner!");
            break;

          case "start-call":
            startCall(true);
            break;

          case "offer":
            handleOffer(data);
            break;

          case "answer":
            handleAnswer(data);
            break;

          case "ice-candidate":
            if (peerConnection && data.candidate) {
              peerConnection.addIceCandidate(
                new RTCIceCandidate(data.candidate)
              );
            }
            break;

          case "partnerLeft":
            setStatus(
              data.message || "Partner disconnected. Waiting for someone new..."
            );
            showPlaceholder(true);
            resetConnection();
            break;

          case "waiting":
            setStatus(data.message || "Waiting for a new partner...");
            showPlaceholder(true);
            resetConnection();
            break;
        }
      }

      async function startCall(isCaller) {
        if (peerConnection) {
          resetConnection();
        }

        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" },
            { urls: "stun:stun3.l.google.com:19302" },
            { urls: "stun:stun4.l.google.com:19302" },
            {
              urls: "turn:openrelay.metered.ca:80",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:443",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
          ],
          iceTransportPolicy: "all",
          iceCandidatePoolSize: 10,
        });

        if (localStream) {
          localStream.getTracks().forEach((track) => {
            if (localStream && peerConnection) {
              peerConnection.addTrack(track, localStream);
            }
          });
        }

        if (peerConnection) {
          peerConnection.ontrack = (event) => {
            if (event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              showPlaceholder(false);
            }
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate && socket) {
              socket.send(
                JSON.stringify({
                  type: "ice-candidate",
                  candidate: event.candidate,
                })
              );
            }
          };

          peerConnection.onconnectionstatechange = () => {
            console.log("Connection state:", peerConnection.connectionState);
            if (
              peerConnection &&
              peerConnection.connectionState === "connected"
            ) {
              setStatus("Connected!");
            }
          };

          peerConnection.onsignalingstatechange = () => {
            console.log("Signaling state:", peerConnection.signalingState);
          };

          if (isCaller) {
            try {
              const offerOptions = {
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
              };

              const offer = await peerConnection.createOffer(offerOptions);
              const highBitrateOffer = setMediaBitrates(offer);
              await peerConnection.setLocalDescription(highBitrateOffer);

              if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(
                  JSON.stringify({
                    type: "offer",
                    sdp: peerConnection.localDescription,
                  })
                );
              }
            } catch (error) {
              console.error("Error creating offer:", error);
            }
          }
        }
      }

      function setMediaBitrates(sdp) {
        if (!sdp) return sdp;

        sdp.sdp = sdp.sdp.replace(
          /a=mid:video\r\n/g,
          "a=mid:video\r\nb=AS:2500\r\n"
        );

        sdp.sdp = sdp.sdp.replace(
          /a=mid:audio\r\n/g,
          "a=mid:audio\r\nb=AS:128\r\n"
        );

        return sdp;
      }

      async function handleOffer(data) {
        if (!peerConnection) {
          startCall(false);
        }

        if (peerConnection && data.sdp) {
          try {
            console.log(
              "Signaling state before setting remote offer:",
              peerConnection.signalingState
            );

            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(data.sdp)
            );

            console.log(
              "Signaling state after setting remote offer:",
              peerConnection.signalingState
            );

            const answer = await peerConnection.createAnswer();
            const highBitrateAnswer = setMediaBitrates(answer);
            await peerConnection.setLocalDescription(highBitrateAnswer);

            console.log(
              "Signaling state after setting local answer:",
              peerConnection.signalingState
            );

            if (socket && socket.readyState === WebSocket.OPEN) {
              socket.send(
                JSON.stringify({
                  type: "answer",
                  sdp: peerConnection.localDescription,
                })
              );
            }
          } catch (error) {
            console.error("Error handling offer:", error);
          }
        }
      }

      async function handleAnswer(data) {
        if (peerConnection && data.sdp) {
          try {
            console.log(
              "Signaling state before setting remote answer:",
              peerConnection.signalingState
            );

            if (peerConnection.signalingState === "have-local-offer") {
              await peerConnection.setRemoteDescription(
                new RTCSessionDescription(data.sdp)
              );
              console.log(
                "Signaling state after setting remote answer:",
                peerConnection.signalingState
              );
            } else {
              console.warn(
                "Cannot set remote answer in state:",
                peerConnection.signalingState
              );
            }
          } catch (error) {
            console.error("Error handling answer:", error);
          }
        }
      }

      function resetConnection() {
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        remoteVideo.srcObject = null;
      }

      function cleanup() {
        resetConnection();

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localVideo.srcObject = null;
        }

        showPlaceholder(true);
      }

      function setStatus(message) {
        statusElement.textContent = message;
      }

      function showPlaceholder(show) {
        placeholder.style.display = show ? "flex" : "none";
      }
    </script>
  </body>
</html>
